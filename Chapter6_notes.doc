6.1 Setting up prisma
    一个ORM 可以当一个translater。
    在server文件夹下使用bun add -d prisma 创建shcema对象的指令
    之后再跑一个 bun add @prisma/client 这是我们与db交互的窗口
    再跑一个：bunx prisma init 初始化 prisma

    之后我们在server的prisma文件夹下就会看见 schema.prisma文件
    修改其中的datasource为
    datasource db {
    provider = "mysql"
    url      = env("DATABASE_URL")
    }

    去到env file中创建
    DATABASE_URL =mysql://root:root的密码@server名称（localhost）：portNumber/databaseName

6.2 Defining the prisma schema
    创建schema方法很简单
    使用model 名称{
        key 类型 @attribute（比如id 也就是primary key）
    }

    最后类似：
    model Product {
    id          Int      @id @default(autoincrement())
    name        String   @db.VarChar(255)
    description String?  @db.Text
    price       Float
    reviews     Review[] //表示这部分信息你需要去Review这个表中查看
    summary     Summary? //？表示可要可不要

    @@map("products") //改名
    }

    model Review {
    id        Int      @id @default(autoincrement())
    author    String   @db.VarChar(255)
    rating    Int      @db.TinyInt
    content   String   @db.Text
    createdAt DateTime @default(now())
    productID Int
    Product   Product  @relation(fields: [productID], references: [id]) //表示桥键，product这个id来自于product表

    @@map("reviews")
    }

6.3 DataGrip
    点击加号，然后选择mySql 对应你的版本（这里是9）
    告诉他连接方式，按照上面的填写就好。

    然后点击0/6那个选择你的database
    在db中一般不是大驼峰类型，所以我们需要用@@map的形式改为小写

6.5 refining the prisma
    有一些不合理的，我们可以用@来重新定义
    这个可以后面再学一次，按情况使用

    在定义修改后，我们应该再在命令行中使用bunx prisma migrate dev 来创建migration
    给个新名字就行，这样migrations就会有个新的名字，来与db交流，你点开查看后就会发现一堆SQL语句

    在db refresh就会发现我们的表单更新了

6.6 populating the databaseName with Realistic Data

    直接chatGPT，给 schema 和prompt 
    我的如下：
    My Schema is defined as below:
    ====
    insert your Schema
    ===
    I would like you to provide me with complete SQL script to populate the products and reviews table in MySQL dataBase based on the schema above. 
    - create 5 products 
    -for each product, insert 5 realistic customer reviews. 
    -make sure each review is long and tailored to the product type 
    - do not include data for the summaries table 
    - output only the SQL script in Markdown format. No comments or explanations.

    创建完毕后，右键我们的DB，然后点new 然后选择Query Console
    粘贴我们的SQL
    用control+A选择全部。然后点击运行。

2.1 Creating the API to fetch review.
    从DB中获取评价
    首先去到router.ts中写入一个get请求 请求端口如下：/api/products/:id/reviews 前端应给我们传入product id
    使用prismaClient 获取全部的reviews关于这个product
    
    我们应该import是 generated/prisma 因为这个Client每次都会重新加载当我们修改我们的 schema.

    从url中读取我们的id，使用req.params方法 （假设valid）

    使用prisma.reviwe.findMany来获取review
     where:{ProductID}

     这等于 SELECT * FROM reviews WHERE productID = @ProductID

     还有更多的选项可以加入，比如orderBY之类的

    findMany return 一个 promist，所以需要await call 然后将request handler换成async

    将结果返回给review

    然后用res.json来看一下结果，用postman

    我们发现如果id invalid 我们会得到一个http页面，这样非常confusing，所以增加validation。

2.2 refactoring-sepration of concerns.
    如同chapter 4中将back end 分层一样。我们也对我们的router进行分层
    再次复习一下每一层的作用：
    1. router，接受和发送http请求。
    2. controller 只接受和验证请求是否合法，传递给下面的组件
    3. service 处理repository上传上来的信息，和对收集上来的信息进行加工将结果返回给controller
    4. repository 负责与外界沟通获取数据，将得到数据上传给service

    所以在我们当前的router中 get方法基本只有验证id是否正确，抓取数据
    所以controller的任务是验证是否是number,下发给service让其干活
        因为service中请求方法为异步，所以await其返回结果。
    res.json(reviews)

    在service中，我们要确保接受到的信息类型，所以使用promist
        这里的类型是Review[]
    注意要使用async方法，因为抓取数据是异步的

    在repository中我们需要使用可以直接return prisma.review.findMany来看起来更整洁
        其是唯一一个知道如何与外界沟通的人，所以在这里创建prisma。
    注意：也需要确保上传为Review[]

    总结：这就好比外联部的人才知道熊猫外卖的电话号，总部经理不需要知道。

2.3 Creating an API for summarizing reviews
    让控制出只出10个review and combine在一起成为一个long String

2.4 Generating summaries
    从chat中先抄来
