Building a Chatbot

2. 选取合适的AI和如何调用
 1. 用bun下载openai 来调用
 2.用new OpenAI实例的方法来赋值apiKey（从env file中）
 3. OpenAI这个实例 赋值到一个client变量中

 接受用户提供的prompt：
 1. 使用post function 因为我们不只是接受，还要传输用户给予的prompt给到服务器。
 2. 提取用户的req body中的prompt（使用destrcutor的方法得到prompt）
 3. 用client.responses.create 方法选择模型，input和其他必要参数
 注意：因为是要发送给服务器，所以需要await服务器返回结果。
 将得到的结果赋值到response 然后用res.json的方式返回output_text.

 adding a middleware function
 为什么需要：中间件就是拦截器/处理器，可以在客户端请求和服务端响应的过程中，执行一些逻辑（比如解析数据、日志记录、权限验证等）。
 在本节课中app.use(express.json()); 就是中间件
 其作用是：
    自动把客户端请求体中的 JSON 字符串解析成 JavaScript 对象
    这样你就可以直接通过 req.body 访问数据，而不用手动解析

 如果这个middleware不存在的话，就会导致prompt这个变量不存在

Testing the API：
 1. 我们使用post man作为fake网页发送请求，查看接收到的请求的状态等信息。
 2.我们需要接入Open AI的API 其方法如下
  首先我们需要去到https://platform.openai.com/docs/models 完成登录和添加fund
  比较模型
  设置max token来控制输出的窗口长度。
  设置temp来控制创意程度，温度越高约混乱
  设置top p来决定我们要选择前百分之多少的选项。

    temp和top_p都是来控制randomness的，
    我们一般只改变其中之一，
    如果不确定，我们应该保持top_p为1 调整temp

 3. 创建API key：
    回归到index.ts中加入环境变量
     在powershell中我们应该使用 setx OPENAI_API_KEY "your_api_key_here"
     在我们server.env file中我们需要设置我们的API_key,这里是真实的。
     在index.ts中我们必须import dotenv from 'dotenv';
     以及： dotenv.config(); 来加载 env环境。

     总结：环境变量不是加在你的电脑上的，而是在你当前工程文件中，但该工程文件并不会被git上传。
     注意：所以你应该同时包括一个.env.example的文件告诉别人如何设置他们自己的.env文件。

4. 此时你就可以用post man的post方法发送请求到 http://localhost:3000/api/chat 使用修改raw为json格式，发送问题得到回复了。
    {
        "prompt":"what is the capital of France?"

    }

Managing Conversation State:
    目前我们的APP是没有上下文记忆功能的，本节的内容是让APP可以记住我们之前问了什么问题
    
    方法1：调用回答的ID
     设置previous question变量来存储，其type应该是String或者null
     每次获得respose之后更新这个变量 last_response_id = response.id
     并在每次发送请求体的时候，提供previous_response_id

     存在的问题是：我们只能追踪上一个问题，对于所有user。
     但现实情况是一个user可以有多个conversation，同时还可以有多个user

    方法2：使用Map，或者dictionary
    映射关系如下：
        conversation 1 -> last_response_id_1
        conversation 2 -> last_response_id_2

    使用new Map<string, string>();

    在请求体（req.body）中我们存在conversationId,使用和获得prompt相同的方式就可以

    使用.set方法更新map 键值分别是conversationId，response.id
    
    发送的请求体也变更成为.get方法获取conversionId

    在现实中，我们是将这些信息存入数据库，但目前来说不需要。

    注：请求体中的变量名都是确定的，而不是随便起的。
    比如: previous_response_id:conversation.get(conversationId)
    而不是：conversation：conversation.get(conversationId)

Input Validation:
    我们不能指望用户能给我们正确的输入，我们需要限制用户
    我们需要使用zod。

    还是在index中我们import zod
    zod的使用只需要设置schema常数，然后用zod的object方法来设置你需要参数的格式信息
    比如：是否trim，最短，最长等

    之后在post请求中，应该首先检查schema是否safe。
    chatSchema.safeParse(req.body)
    将得到的对象包装到一个变量里面，然后检查其是否是success的，如果不是则
    res.status(400).json({ errors: parseResult.error.format() });
    让用户知道其错误在哪。

Error Handling:
    我们的服务器会因为各种原因无法访问，但当其出现时，我们不希望看到一个html写满了报错的问题
    此时我们就可以使用 try catch方法来捕捉error，并设置标准返回信息。
    在try中 我们包含所有需要访问服务器需要进行的程序（不包含zod的schma）
    catch中设置返回请求的状态为500标志内部服务器错误
    和一个json（{error：错误原因}）


3.1 Refactoring the BackEnd
    为了能够更好的分层，我们需要首先了解back end 到底是如何应该怎么分层
        顶层: controllers | gateway 用于接收HTTP请求，和返回 HTTP响应体
        中层：services | Application logic 比如叫OPENAI的api就属于这一层的
        底层：repositories | data 用于存储数据。

3.2 extracting conversation repository：
    对于我们在3.1聊到的layer，我们永远是由上到下，
        例如顶层可以与中层对话，但底层无法与顶层对话。
    我们本次只调整我们的repository

    我们目前的代码中MAP 和更新map的代码就属于repository层的。

    首先先提取出MAP这个代码，以及其更新获取方式到server下的repositories文件夹中的conversation.repository.ts中加入环境变量
    因为我们这是implementation detail，我们并不需要对外暴露，我们使用的是map方法
    因此不需要export整个conversation这个map，而是创建一些新的function，然后export这些function
    例如，get，set等

    但是如果你只这么做的话，会导致在index这个文件夹中，看代码的人并不知道getLastResponseId和 setLastResponsedID是repository的function
    这时候，我们就需要定义一个对象叫做conversationRepository，其中包含这两个function
    这样在外部调用的时候会调用这个对象的方法，这样就清晰了。

3.3 Extracting chat service
    这一次我们的implement detail就是这个OPENAI的api key调用了
    剩下的send Message方法我们可以直接包装进chatService中。

    但是需要注意，如果我们就这么结束了，这是一个leaky abstraction
    因为在外部调用时，我们会使用response.output_text
    这是openAI独有的调用方法
    
    所以为了解决这个问题，我们可以创建一个interface对象
    其中包含message和id
    然后修改sendMessage方法使其promist可以返回一个ChatResponse函数。

    这样的话当我们需要修改LLM模型时，只需要更新return后面message的方法就可以了

3.4 extracting chat Controller
    现在，我们希望把arrow function里面剩下的内容单独提取到一个controller中
    这样我们只需要post调用这一个方法就可以

    同时我们应该调整chat的schema也到这里面

3.5 Extracting Router
    现在index.ts还好，没有很多router，但是未来会有很多，所以可以建立一个router file
    具体实现方式直接看代码就行，没有什么fancy的。