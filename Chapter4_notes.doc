Building a Chatbot

2. 选取合适的AI和如何调用
 1. 用bun下载openai 来调用
 2.用new OpenAI实例的方法来赋值apiKey（从env file中）
 3. OpenAI这个实例 赋值到一个client变量中

 接受用户提供的prompt：
 1. 使用post function 因为我们不只是接受，还要传输用户给予的prompt给到服务器。
 2. 提取用户的req body中的prompt（使用destrcutor的方法得到prompt）
 3. 用client.responses.create 方法选择模型，input和其他必要参数
 注意：因为是要发送给服务器，所以需要await服务器返回结果。
 将得到的结果赋值到response 然后用res.json的方式返回output_text.

 adding a middleware function
 为什么需要：中间件就是拦截器/处理器，可以在客户端请求和服务端响应的过程中，执行一些逻辑（比如解析数据、日志记录、权限验证等）。
 在本节课中app.use(express.json()); 就是中间件
 其作用是：
    自动把客户端请求体中的 JSON 字符串解析成 JavaScript 对象
    这样你就可以直接通过 req.body 访问数据，而不用手动解析

 如果这个middleware不存在的话，就会导致prompt这个变量不存在

Testing the API：
 1. 我们使用post man作为fake网页发送请求，查看接收到的请求的状态等信息。
 2.我们需要接入Open AI的API 其方法如下
  首先我们需要去到https://platform.openai.com/docs/models 完成登录和添加fund
  比较模型
  设置max token来控制输出的窗口长度。
  设置temp来控制创意程度，温度越高约混乱
  设置top p来决定我们要选择前百分之多少的选项。

    temp和top_p都是来控制randomness的，
    我们一般只改变其中之一，
    如果不确定，我们应该保持top_p为1 调整temp

 3. 创建API key：
    回归到index.ts中加入环境变量
     在powershell中我们应该使用 setx OPENAI_API_KEY "your_api_key_here"
     在我们server.env file中我们需要设置我们的API_key,这里是真实的。
     在index.ts中我们必须import dotenv from 'dotenv';
     以及： dotenv.config(); 来加载 env环境。

     总结：环境变量不是加在你的电脑上的，而是在你当前工程文件中，但该工程文件并不会被git上传。
     注意：所以你应该同时包括一个.env.example的文件告诉别人如何设置他们自己的.env文件。

4. 此时你就可以用post man的post方法发送请求到 http://localhost:3000/api/chat 使用修改raw为json格式，发送问题得到回复了。
    {
        "prompt":"what is the capital of France?"

    }

Managing Conversation State:
    目前我们的APP是没有上下文记忆功能的，本节的内容是让APP可以记住我们之前问了什么问题
    
    方法1：调用回答的ID
     设置previous question变量来存储，其type应该是String或者null
     每次获得respose之后更新这个变量 last_response_id = response.id
     并在每次发送请求体的时候，提供previous_response_id

     存在的问题是：我们只能追踪上一个问题，对于所有user。
     但现实情况是一个user可以有多个conversation，同时还可以有多个user

    方法2：使用Map，或者dictionary
    映射关系如下：
        conversation 1 -> last_response_id_1
        conversation 2 -> last_response_id_2

    使用new Map<string, string>();

    在请求体（req.body）中我们存在conversationId,使用和获得prompt相同的方式就可以

    使用.set方法更新map 键值分别是conversationId，response.id
    
    发送的请求体也变更成为.get方法获取conversionId

    在现实中，我们是将这些信息存入数据库，但目前来说不需要。

    注：请求体中的变量名都是确定的，而不是随便起的。
    比如: previous_response_id:conversation.get(conversationId)
    而不是：conversation：conversation.get(conversationId)

Input Validation:
    我们不能指望用户能给我们正确的输入，我们需要限制用户
    我们需要使用zod。

    还是在index中我们import zod
    zod的使用只需要设置schema常数，然后用zod的object方法来设置你需要参数的格式信息
    比如：是否trim，最短，最长等

    之后在post请求中，应该首先检查schema是否safe。
    chatSchema.safeParse(req.body)
    将得到的对象包装到一个变量里面，然后检查其是否是success的，如果不是则
    res.status(400).json({ errors: parseResult.error.format() });
    让用户知道其错误在哪。